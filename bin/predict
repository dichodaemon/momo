#! /usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os

BASE_DIR = os.path.abspath( os.path.join( os.path.dirname( __file__ ), ".." ) )
path     = os.path.abspath( os.path.join( BASE_DIR, "python" ) )
sys.path.append( path )

import time
import momo
import momo.planning
import numpy as np
import matplotlib.pylab as pl
import scipy.ndimage as ni


class Experiment( object ):
  def __init__( self, grid_x, grid_y, delta, width, height, data, track, origin, destination ):
    self.grid_x = grid_x
    self.grid_y = grid_y
    self.delta  = delta
    self.width  = width
    self.height = height
    self.cases  = []
    self.data   = data
    self.track  = track
    self.origin = origin
    self.destination = destination

  def add_case( self, cost_function, format_string, legend ):
    self.cases.append( {
      "cost_function": cost_function, 
      "format_string": format_string,
      "legend": legend
    } )

  def animate( self, quiver = [] ):
    for case in self.cases:
      case["planner"] = momo.planning.full_plan( 
        case["cost_function"],
        self.grid_x, self.grid_y,
        self.width, self.height,
        self.delta
      )
      case["path_x"] = []
      case["path_y"] = []
      case["current"] = np.array( self.origin ) * 1.
    x = {}
    y = {}
    x1 = []
    y1 = []
    count = 0
    for f in momo.frames( self.data ):
      count += 1
      if count % 1 != 0:
        continue
      pl.clf()
      pl.axis( "scaled" )
      pl.xlim( self.grid_x, self.grid_x + self.width )
      pl.ylim( self.grid_y - self.height, self.grid_y )
      tm = time.time()
      frame = []
      track_observed = False
      for o in f:
        o_id = o[2]
        o_x  = o[3]
        o_y  = o[4]
        o_dx = o[5]
        o_dy = o[6]
        if not o_id in x:
          x[o_id] = []
          y[o_id] = []
        x[o_id].append( o_x )
        y[o_id].append( o_y )
        if o_id != self.track:
          frame.append( np.array( [o_x, o_y, o_dx, o_dy] ) )
        else:
          track_observed = True
      for o_id in x.keys():
        if o_id == self.track:
          pl.plot( x[o_id], y[o_id], 'r' )
        else:
          pl.plot( x[o_id][-1:], y[o_id][-1:], 'b.', markersize = 10 )
      if len( x[self.track] ) > 1:
        d = momo.distance( 
          np.array( [x[self.track][-2], y[self.track][-2]] ), 
          np.array( [x[self.track][-1], y[self.track][-1]] ) 
        )
        for case in self.cases:
          if track_observed:
            p, _x, _y, imx, imy = case["planner"]( self.destination, case["current"], frame, d )
            pl.imshow( case["planner"].grid, pl.cm.jet, None, None, "none", extent = (self.grid_x, self.grid_x +self.width, self.grid_y - self.height, self.grid_y ) )
            pl.quiver( _x, _y, imx, imy, color = case["format_string"][0] )
            case["current"] = p
            case["path_x"].append( p[0] )
            case["path_y"].append( p[1] )
          pl.plot( case["path_x"], case["path_y"], case["format_string"] )
          pl.plot( 
            [case["path_x"][-1], self.destination[0]],
            [case["path_y"][-1], self.destination[1]],
            "k"
          )
      #pl.legend()
      pl.draw()

      #for agent_id in x.keys():
        #if len( x[agent_id] ) == len( self.agents[agent_id] ):
          #del x[agent_id]
          #del y[agent_id]

cost_function = momo.cost_functions.__dict__[sys.argv[1]]
model = sys.argv[2]
data  = momo.read_data( sys.argv[3] )

if len( sys.argv ) > 4:
  track = int( sys.argv[4] )
else:
  max_count = 0
  track = -1
  counts = {}
  for o in data:
    if not o[2] in counts:
      counts[o[2]] = 0
    counts[o[2]] += 1
    if counts[o[2]] > max_count:
      track = o[2]
      max_count = counts[o[2]]


first = -1
last  = -1
origin = None
destination = None
for o in data:
  if o[2] == track:
    if first == -1:
      first = o[0]
      origin = o
    last = o[0]
    destination = o

origin = origin[:]
destination = destination[:]
origin[3] = -10.
origin[4] = -2
destination[3] = 10
destination[4] = -3

samples = []
for o in data:
  if o[0] >= first and o[0] <= last:
    samples.append( o )

# Experiment 1

minx = min( data, key = lambda x: x[3] )[3]
maxx = max( data, key = lambda x: x[3] )[3]
miny = min( data, key = lambda y: y[4] )[4]
maxy = max( data, key = lambda y: y[4] )[4]

exp1 = Experiment( minx, maxy, .5, maxx - minx, maxy - miny, samples, track, origin[3:], destination[3:] )

cf = cost_function.load( open( model ) )

exp1.add_case( 
  cf,
  "g.",
  "%s/%s" % ( cost_function.__name__, cf.module.__name__ )
)

pl.figure( 1, figsize = ( 20, 10 ), dpi = 75 )
pl.ion()
exp1.animate( ["real/ggmm"] )
