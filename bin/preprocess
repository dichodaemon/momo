#! /usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os

BASE_DIR = os.path.abspath( os.path.join( os.path.dirname( __file__ ), ".." ) )
path     = os.path.abspath( os.path.join( BASE_DIR, "python" ) )
sys.path.append( path )

import time
import momo
import momo.planning
import numpy as np
import matplotlib.pylab as pl
import scipy.ndimage as ni


def f( x, delta ):
  result = np.array( x.shape )
  result[3] = x[3]
  result[2] = x[2]
  result[0] = x[0] + delta * ( x[2]**2 + x[3]**2 )**0.5 * cos( atan( x[3] / x[2] ) )
  result[1] = x[1] + delta * ( x[2]**2 + x[3]**2 )**0.5 * sin( atan( x[3] / x[2] ) )
  return result

def jacobian( f, x ):
  result = []
  for i in xrange( x.shape[0] ):
    result.append( ( f( x, 1E-6 ) - f( x, 0 ) ) * 1E6 )
  return np.transpose( np.array( result ) )


class Track( object ):
  def __init__( self, observation ):
    self.__mean = np.array( 4 )
    self.__mean[0:2] = observation
    self.q = np.array( [
      [ 0.01, 0, 0, 0], 
      [ 0, 0.01, 0, 0], 
      [ 0, 0, 0.5, 0], 
      [ 0, 0, 0, 0.5]
    ] )
    self.r = np.ones( 2 ) * 0.3
    self.p = np.ones( 4 )
  
  def predict( self, delta ):



  def update( self, observation ):
    self.__mean = observation


  def get_mean( self ):
    return self.__mean

  def set_mean( self, value ):
    self.__mean = value

  mean = property( get_mean, set_mean )

def read_data( filename ):
  f = open( filename )
  data = [[v for v in l.split()] for l in f]
  f.close()
  return data

def filter_data( data ):
  result = []
  tracks = {}
  old_timestamp = None
  delta = 0
  for o in data:
    frame = float( o[0] )
    timestamp = float( o[1] )
    o_id = int( o[2] )
    x = float( o[3] )
    y = float( o[4] )

    if timestamp != old_timestamp:
      if old_timestamp != None:
        delta = timestamp - old_timestamp
      old_timestamp = timestamp
      for t in tracks.values():
        t.predict( delta )
    if o_id in tracks:
      tracks[o_id].update( np.array( [x, y] ) )
    else:
      tracks[o_id] = Track( np.array( [x, y] ) )
    result.append( [frame, timestamp, o_id, 1.0 * tracks[o_id].mean] )
  return result

data = filter_data( read_data( sys.argv[1] ) )

print data
