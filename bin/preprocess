#! /usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os

BASE_DIR = os.path.abspath( os.path.join( os.path.dirname( __file__ ), ".." ) )
path     = os.path.abspath( os.path.join( BASE_DIR, "python" ) )
sys.path.append( path )

import time
import momo
import momo.planning
import numpy as np
import matplotlib.pylab as pl
import scipy.ndimage as ni

class Track( object ):
  def __init__( self, observation ):
    self.__mean = np.array( [0.] * 4 )
    self.__mean[0:2] = observation
    self.a = np.array( [
      [ 1., 0., 1., 0. ],
      [ 0., 1., 0., 1. ],
      [ 0., 0., 1., 0. ],
      [ 0., 0., 0., 1. ]
    ] )
    self.c = np.array( [
      [ 1., 0., 0., 0. ],
      [ 0., 1., 0., 0. ]
    ] )
    self.r = 0.002
    self.q = np.eye( 2 ) * 1.
    self.p = np.eye( 4 ) * 1.

  def predict( self, delta ):
    self.__mean = np.dot( self.a, self.__mean )
    d3 = delta**3 * self.r / 3.
    d2 = delta**2 * self.r / 2.
    d  = delta * self.r
    r = np.array( [
      [d3, 0., d2, 0.],
      [0., d3, 0., d2],
      [d2, 0.,  d,  0],
      [0,  d2,  0,  d]
    ] )
    self.p = np.dot( np.dot( self.a, self.p ), np.transpose( self.a ) ) + self.r

  def update( self, observation ):
    tmp = np.dot( np.dot( self.c, self.p ), np.transpose( self.c ) ) + self.q
    tmp = np.linalg.inv( tmp )
    k = np.dot( np.dot( self.p, np.transpose( self.c ) ), tmp )
    self.__mean = self.__mean + np.dot( k, observation - np.dot( self.c, self.__mean ) )
    self.p = np.dot( np.eye( 4 ) - np.dot( k, self.c ), self.p )

  def get_mean( self ):
    return self.__mean

  def set_mean( self, value ):
    self.__mean = value

  mean = property( get_mean, set_mean )

def split_line( line ):
  v = line.split()
  return [
    int( v[0] ), float( v[1] ), int( v[2] ), 
    float( v[3] ), float( v[4] )
  ]

def read_data( filename ):
  f = open( filename )
  data = [split_line( l ) for l in f]
  f.close()
  return data

def filter_data( data ):
  result = []
  tracks = {}
  old_timestamp = None
  delta = 0
  for o in data:
    frame, timestamp, o_id, x, y  = o
    if timestamp != old_timestamp:
      if old_timestamp != None:
        delta = timestamp - old_timestamp
      old_timestamp = timestamp
      for t in tracks.values():
        t.predict( delta )
    if o_id in tracks:
      tracks[o_id].update( np.array( [x, y] ) )
    else:
      tracks[o_id] = Track( np.array( [x, y] ) )
    result.append( [frame, timestamp, o_id, 1.0 * tracks[o_id].mean] )
  return result

data = filter_data( read_data( sys.argv[1] ) )

for d in data:
  print d[0], d[1], d[2], d[3][0], d[3][1], d[3][2], d[3][3]


