#! /usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os

BASE_DIR = os.path.abspath( os.path.join( os.path.dirname( __file__ ), ".." ) )
path     = os.path.abspath( os.path.join( BASE_DIR, "python" ) )
sys.path.append( path )

import momo
import momo.planning
import numpy as np
import matplotlib.pylab as pl
import scipy.ndimage as ni

def read_data( filename ):
  f = open( filename )
  result = [[float( v ) for v in l.split()] for l in f]
  f.close()
  return result

def display_cost( module, cost_function, pixel_size = 100, image_size = 10 ):
  cost_map = np.zeros( ( pixel_size, pixel_size ) )
  delta = 1.0 * image_size / pixel_size
  side = image_size / 2.0
  update_grid( 
    cost_function, -side, side, delta, 
    np.array([0., 0, 1, 0]) , cost_map 
  )
  pl.imshow( cost_map, pl.cm.jet, None, None, "none", extent = (-side, side, -side, side ) )

def update_grid( cost_function, grid_x, grid_y, delta, agent, grid ):
  y = grid_y
  for i in xrange( grid.shape[0] ):
    x = grid_x
    for j in xrange( grid.shape[1] ):
      grid[i, j] = cost_function( np.array( [x, y] ), agent )
      x += delta
    y -= delta

def compute_gradient( grid, grid_x, grid_y, delta, width, height ):
  x, y = pl.meshgrid( 
    pl.linspace( grid_x, grid_x + width, width / delta, endpoint = False ), 
    pl.linspace( grid_y, grid_y - height, height / delta, endpoint = False )
  )
  imx = pl.zeros( grid.shape )
  imy = pl.zeros( grid.shape )
  ni.filters.sobel( grid, 1, imx )
  ni.filters.sobel( grid, 0, imy )
  imx = -imx
  return x, y, imx, imy

def descend_gradient( start, length, grid_x, grid_y, delta, imx, imy, step = 0.05 ):
  point = start * 1.
  while True:
    coords = pl.array( [int( ( point[0] - grid_x ) / delta ), int( ( grid_y - point[1] ) / delta ) ] )
    angle = pl.array( [imx[coords[1], coords[0]], imy[coords[1], coords[0] ] ] )
    angle = angle / ( angle[0]**2 + angle[1]**2 )**0.5
    if length > step:
      point = point + angle * step
    else:
      point = point + angle * length
      break
    length -= step
  return point

class Experiment( object ):
  def __init__( self, grid_x, grid_y, delta, width, height, p1, p2 ):
    self.grid_x = grid_x
    self.grid_y = grid_y
    self.delta  = delta
    self.width  = width
    self.height = height
    self.p1     = p1
    self.p2     = momo.compute_angles( p2[:, :2] )
    self.cases  = []

  def add_case( self, cost_function, format_string, legend ):
    self.cases.append( {
      "cost_function": cost_function, 
      "format_string": format_string,
      "legend": legend
    } )

  def animate( self, quiver = [] ):
    grid = np.zeros( ( self.height / self.delta, self.width / self.delta ) )

    for i in xrange( self.p2.shape[0] ):
      if i == 0 or abs( self.p2[i,0] - self.p2[i-1,0] ) > 1.0:
        distance = 0
        goal = self.p2[i]
        for c in self.cases:
          c["planned"] = [self.p1[i,0:2]]
        start = i
      else:
        d = self.p1[i, :2] - self.p1[i-1, :2]
        distance = pl.dot( d, d )**0.5
      pl.clf()
      pl.axis( "scaled" )
      pl.xlim( self.grid_x, self.grid_x + self.width )
      pl.ylim( self.grid_y - self.height, self.grid_y )
      for c in self.cases:
        update_grid( 
          c["cost_function"], self.grid_x, self.grid_y, self.delta, self.p2[i], grid 
        )
        cummulated, phi = momo.planning.forward( grid, self.grid_x, self.grid_y, self.delta, goal )
        path = momo.planning.get_path( phi, self.grid_x, self.grid_y, self.delta, self.p1[i] )
        x, y , imx, imy = compute_gradient( cummulated, self.grid_x, self.grid_y, self.delta, self.width, self.height )
        if c["legend"] in quiver:
          pl.quiver( x, y, imx, imy, color = c["format_string"][0] )
        point = c["planned"][-1]
        point = descend_gradient( point, distance, self.grid_x, self.grid_y, self.delta, imx, imy )
        c["planned"].append( point )
        pl.plot( pl.array( c["planned"] )[:,0], pl.array( c["planned"] )[:, 1], c["format_string"], markersize = 10, label = c["legend"] )
      pl.plot( self.p2[i, 0], self.p2[i, 1], 'ro', markersize = 20 )
      pl.plot( self.p1[start:i + 1, 0], self.p1[start:i + 1, 1], 'r', label = "data" )
      pl.legend()
      pl.draw()

files1 = [ 2, 4, 5, 8, 10]
files2 = [ 1, 3, 6, 7, 9]
agent1 = []
agent2 = []
for i in xrange( len( files1 ) ):
  agent1 += read_data( "data/tracks/trk_00%s.label_real" % ( "%i" % files1[i] ).rjust( 2, "0" ) )
  agent2 += read_data( "data/tracks/trk_00%s.label_real" % ( "%i" % files2[i] ).rjust( 2, "0" ) )
agent1 = np.array( agent1 )
agent2 = np.array( agent2 )

# Experiment 1

exp1 = Experiment( -5., 5., 0.25, 15, 10, agent1, agent2 )

exp1.add_case( 
  momo.cost_functions.weighted_mahalanobis( 
    momo.features.bins, agent1, agent2, None
  ),
  "g.",
  "bins/maha"
)

exp1.add_case( 
  momo.cost_functions.weighted_mahalanobis( 
    momo.features.real, agent1, agent2, None
  ),
  "m.",
  "real/maha"
)

values = pl.array( [
  #2.9818323238080358e+00,
  7.2213183456178232e-01,
  2.1149875757160411e-01,
  3.9621328379720239e-01,
  4.4607338979218342e-01,
  1.3542936628212632e-01,
  6.5887691716844687e-01,
  1.7442128092821079e+00,
  5.8829665935162367e+00,
  8.0276057251236477e+00
] )

exp1.add_case( 
  momo.cost_functions.linear_combination( values ),
  "b.",
  "bins/linear"
)

exp1.add_case( 
  momo.cost_functions.gaussian_mixture( momo.features.real, agent1, agent2, 4 ),
  "y.",
  "real/gmm"
)

#exp1.add_case( 
  #momo.cost_functions.growing_gaussian_mixture( momo.features.real, agent1, agent2 ),
  #"k.",
  #"real/ggmm"
#)


pl.figure( 1, figsize = ( 20, 10 ), dpi = 75 )
#display_cost( momo.features.bins, momo.cost_functions.linear_combination( values ), 100, 10 )
#pl.figure( 2, figsize = ( 20, 10 ), dpi = 75 )
#display_cost( momo.features.bins, momo.cost_functions.weighted_mahalanobis( 
    #momo.features.real, agent1, agent2, None
  #), 100, 10 )
#pl.show()
pl.ion()
exp1.animate( ["real/gmm"] )

